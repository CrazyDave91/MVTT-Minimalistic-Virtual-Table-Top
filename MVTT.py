"""
********************************************************************************
This code was generated by an AI language model (ChatGPT, version GPT-4) on 2025-03-21.
DISCLAIMER: This code is provided "as-is" without any warranty. It is intended for
educational and informational purposes only. Use it at your own risk.
********************************************************************************
"""

import sys
from PyQt5.QtCore import Qt, QTimer, QRectF, QPointF
from PyQt5.QtGui import QPixmap, QPen, QColor, QPainter, QImage
from PyQt5.QtWidgets import (
    QApplication,
    QMainWindow,
    QGraphicsView,
    QGraphicsScene,
    QGraphicsPixmapItem,
    QGraphicsRectItem,
    QLabel,
    QWidget,
    QVBoxLayout,
)

# Default image path if none is provided
DEFAULT_IMAGE_PATH = "default.jpg"

# Fixed dot size in device pixels for the yellow points
FIXED_YELLOW_DOT_SIZE = 4

# -----------------------------
# RevealRect: Non-interactive green rectangle for revealing parts of the image
# -----------------------------
class RevealRect(QGraphicsRectItem):
    def __init__(self, rect, parent=None):
        super().__init__(rect, parent)
        self.setPen(QPen(QColor(0, 255, 0), 2))
        self.setBrush(QColor(0, 255, 0, 50))
        self.setFlags(QGraphicsRectItem.GraphicsItemFlags(0))

# -----------------------------
# SelectionRect: Red rectangle that defines the exposed area.
# Its local coordinates always start at (0,0) and it displays a yellow dotted "ruler"
# along its border. The spacing of the dots is dynamically calculated so that when the red
# rectangle is projected onto the second monitor, the gap between the dots equals 1 inch.
# -----------------------------
class SelectionRect(QGraphicsRectItem):
    def __init__(self, rect, main_window, parent=None):
        # Define local rectangle starting at (0,0)
        super().__init__(QRectF(0, 0, rect.width(), rect.height()), parent)
        self.main_window = main_window
        # The red rectangle is selectable and movable.
        # In Cover Mode it is only movable if Shift is held.
        self.setFlags(QGraphicsRectItem.ItemIsSelectable | 
                      QGraphicsRectItem.ItemIsMovable | 
                      QGraphicsRectItem.ItemSendsGeometryChanges)
        self.setPen(QPen(QColor(255, 0, 0), 2))
        self.setBrush(QColor(255, 0, 0, 50))
        self.moving = False  # Indicates if the rectangle is being moved
        # The yellow dots will have a fixed size (in device pixels)
        self.yellow_size = FIXED_YELLOW_DOT_SIZE

    def mousePressEvent(self, event):
        if self.main_window.coverModeEnabled:
            # In Cover Mode, allow movement only if Shift is pressed.
            if event.button() == Qt.LeftButton and (event.modifiers() & Qt.ShiftModifier):
                self.moving = True
                super().mousePressEvent(event)
            else:
                event.ignore()
        else:
            # There is only Cover Mode in this implementation.
            if event.button() == Qt.LeftButton:
                self.moving = True
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self.moving:
            super().mouseMoveEvent(event)
        else:
            event.ignore()

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton and self.moving:
            self.moving = False
            super().mouseReleaseEvent(event)
        else:
            event.ignore()

    def wheelEvent(self, event):
        # Zoom using Shift+Scroll; keep the top-left corner fixed.
        if event.modifiers() & Qt.ShiftModifier:
            delta = event.delta()
            factor = 1.0 - (delta / 6000.0)
            rect = self.rect()  # Local rectangle starting at (0,0)
            new_width = rect.width() * factor
            new_height = rect.height() * factor
            # Get the scene position of the local (0,0) point (top-left corner)
            top_left_scene = self.mapToScene(QPointF(0, 0))
            # Set the new local rectangle starting at (0,0)
            self.setRect(0, 0, new_width, new_height)
            # Reposition the item so that the top-left corner remains fixed
            self.setPos(top_left_scene)
            event.accept()
        else:
            event.ignore()

    def paint(self, painter, option, widget):
        # Draw the red rectangle's fill (without its border)
        painter.save()
        painter.setBrush(self.brush())
        painter.setPen(Qt.NoPen)
        painter.drawRect(self.rect())
        painter.restore()
        
        # --- Draw the yellow dotted "ruler" along the border ---
        # We want the spacing between the dots to be such that when the red rectangle is projected
        # onto the second monitor, the distance between dots equals 1 inch.
        # To compute the spacing in the red rectangle's local coordinates, we first map its local rect to scene.
        sel_rect_scene = self.mapRectToScene(self.rect())
        # Calculate the scale factor from the red rectangle (scene) to the second monitor.
        scale_factor = min(
            self.main_window.second_screen_geometry.width() / sel_rect_scene.width(),
            self.main_window.second_screen_geometry.height() / sel_rect_scene.height()
        )
        # 1 inch corresponds to logicalDotsPerInch pixels on the second monitor.
        spacing = self.main_window.second_qscreen.logicalDotsPerInch() / scale_factor

        # The dot size remains fixed in device pixels.
        dot_diameter = FIXED_YELLOW_DOT_SIZE  
        dot_radius = dot_diameter / 2

        painter.setPen(Qt.NoPen)
        painter.setBrush(QColor(255, 255, 0, 200))  # Yellow, somewhat opaque

        local_rect = self.rect()  # Local rectangle (origin at (0,0))

        # Draw dots along the top edge:
        x = 0
        while x <= local_rect.width():
            painter.drawEllipse(QPointF(x, 0), dot_radius, dot_radius)
            x += spacing
        # Draw dots along the bottom edge:
        x = 0
        while x <= local_rect.width():
            painter.drawEllipse(QPointF(x, local_rect.height()), dot_radius, dot_radius)
            x += spacing
        # Draw dots along the left edge:
        y = 0
        while y <= local_rect.height():
            painter.drawEllipse(QPointF(0, y), dot_radius, dot_radius)
            y += spacing
        # Draw dots along the right edge:
        y = 0
        while y <= local_rect.height():
            painter.drawEllipse(QPointF(local_rect.width(), y), dot_radius, dot_radius)
            y += spacing

        # End of paint()

# -----------------------------
# MainView: Handles the scene display and drawing of reveal rectangles
# -----------------------------
class MainView(QGraphicsView):
    def __init__(self, scene, main_window, parent=None):
        super().__init__(scene, parent)
        self.main_window = main_window
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.setMouseTracking(True)
        self.setBackgroundBrush(Qt.white)
        self._reveal_start = None
        self._temp_reveal_item = None

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self.fitInView(self.sceneRect(), Qt.KeepAspectRatio)

    def mousePressEvent(self, event):
        # In Cover Mode: If Shift is NOT pressed, start drawing a reveal rectangle.
        if self.main_window.coverModeEnabled and not (event.modifiers() & Qt.ShiftModifier) and event.button() == Qt.LeftButton:
            self._reveal_start = self.mapToScene(event.pos())
            self._temp_reveal_item = QGraphicsRectItem(QRectF(self._reveal_start, self._reveal_start))
            self._temp_reveal_item.setPen(QPen(QColor(0, 255, 0), 2))
            self._temp_reveal_item.setBrush(QColor(0, 255, 0, 50))
            self._temp_reveal_item.setFlags(QGraphicsRectItem.GraphicsItemFlags(0))
            self.scene().addItem(self._temp_reveal_item)
            event.accept()
        else:
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self._reveal_start is not None:
            current_point = self.mapToScene(event.pos())
            rect = QRectF(self._reveal_start, current_point).normalized()
            self._temp_reveal_item.setRect(rect)
            event.accept()
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        if self._reveal_start is not None and event.button() == Qt.LeftButton:
            final_rect = self._temp_reveal_item.rect()
            if final_rect.width() > 5 and final_rect.height() > 5:
                permanent_reveal = RevealRect(final_rect)
                self.scene().addItem(permanent_reveal)
                self.main_window.reveal_rectangles.append(permanent_reveal)
            self.scene().removeItem(self._temp_reveal_item)
            self._temp_reveal_item = None
            self._reveal_start = None
            event.accept()
        else:
            super().mouseReleaseEvent(event)

# -----------------------------
# SecondWindow: Displays the composite image (non-interactive)
# -----------------------------
class SecondWindow(QWidget):
    def __init__(self, screen_geometry, second_qscreen, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Second Screen")
        self.setStyleSheet("background-color: black;")
        self.setGeometry(screen_geometry)
        self.second_qscreen = second_qscreen  # For DPI calculations
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        self.label = QLabel()
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setStyleSheet("background-color: black;")
        self.label.setMargin(0)
        layout.addWidget(self.label)
        self.setLayout(layout)
        self.showFullScreen()
    
    def updateImage(self, pixmap: QPixmap):
        self.label.setPixmap(pixmap)

# -----------------------------
# MainWindow: Main application window and shortcut handling
# -----------------------------
class MainWindow(QMainWindow):
    def __init__(self, image_path, monitor_index=None):
        super().__init__()
        # Only Cover Mode is available.
        self.coverModeEnabled = True  
        self.invertedCover = False  # Default: non-inverted
        self.current_mode_title = "MVTT - Cover Mode"
        self.setWindowTitle(self.current_mode_title)
        
        # Load the main image (for display and processing)
        self.image = QImage(image_path)
        if self.image.isNull():
            print("Error: Could not load image.")
            sys.exit(1)
        self.pixmap = QPixmap.fromImage(self.image)
        
        # Create a scene matching the dimensions of the main image.
        self.scene = QGraphicsScene(0, 0, self.image.width(), self.image.height())
        self.pixmap_item = QGraphicsPixmapItem(self.pixmap)
        self.scene.addItem(self.pixmap_item)
        
        # Determine the monitor for the second window and get its QScreen object.
        screens = QApplication.screens()
        if monitor_index is None:
            second_screen = screens[1] if len(screens) > 1 else screens[0]
        else:
            second_screen = screens[monitor_index] if monitor_index < len(screens) else screens[0]
        self.second_qscreen = second_screen
        self.second_screen_geometry = second_screen.geometry()
        aspect_ratio = self.second_screen_geometry.width() / self.second_screen_geometry.height()
        
        # Create the red selection rectangle.
        # Define it with local coordinates starting at (0,0) and then position it.
        rect_width = self.image.width() / 3
        rect_height = rect_width / aspect_ratio
        init_rect = QRectF(0, 0, rect_width, rect_height)
        self.selection_rect = SelectionRect(init_rect, main_window=self)
        pos_x = (self.image.width() - rect_width) / 2
        pos_y = (self.image.height() - rect_height) / 2
        self.selection_rect.setPos(pos_x, pos_y)
        # Use a fixed dot size for the yellow ruler.
        self.selection_rect.yellow_size = FIXED_YELLOW_DOT_SIZE
        self.scene.addItem(self.selection_rect)
        
        # List of reveal rectangles.
        self.reveal_rectangles = []
        
        self.view = MainView(self.scene, self)
        self.setCentralWidget(self.view)
        self.resize(self.image.width() // 2, self.image.height() // 2)
        self.show()
        
        self.second_window = SecondWindow(self.second_screen_geometry, self.second_qscreen)
        
        self.timer = QTimer()
        self.timer.timeout.connect(self.updateSecondWindow)
        self.timer.start(30)
    
    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Shift:
            self.setWindowTitle("MVTT - Moving Mode")
            event.accept()
            return
        elif event.key() == Qt.Key_I:
            self.invertedCover = not self.invertedCover
            mode_text = "Inverted Cover Mode" if self.invertedCover else "Cover Mode"
            self.current_mode_title = f"MVTT - {mode_text}"
            if not (event.modifiers() & Qt.ShiftModifier):
                self.setWindowTitle(self.current_mode_title)
        elif event.key() == Qt.Key_R:
            for reveal in self.reveal_rectangles:
                self.scene.removeItem(reveal)
            self.reveal_rectangles = []
        elif event.key() == Qt.Key_PageUp:
            self.resizeSelectionRect(0.98)
        elif event.key() == Qt.Key_PageDown:
            self.resizeSelectionRect(1.02)
        else:
            super().keyPressEvent(event)
    
    def keyReleaseEvent(self, event):
        if event.key() == Qt.Key_Shift:
            self.setWindowTitle(self.current_mode_title)
            event.accept()
            return
        else:
            super().keyReleaseEvent(event)
    
    def resizeSelectionRect(self, factor):
        old_rect = self.selection_rect.rect()  # Local rect starting at (0,0)
        new_width = old_rect.width() * factor
        new_height = old_rect.height() * factor
        # Set new local rect with origin (0,0) so that the top-left corner remains fixed.
        self.selection_rect.setRect(0, 0, new_width, new_height)
        # The position remains unchanged, so the top-left corner in scene coordinates stays the same.
    
    def updateSecondWindow(self):
        sel_rect = self.selection_rect.mapRectToScene(self.selection_rect.rect()).toRect()
        
        # Create a composite image with a black background.
        composite = QImage(sel_rect.size(), QImage.Format_ARGB32)
        composite.fill(Qt.black)
        
        if self.invertedCover:
            intersection = sel_rect.intersected(self.image.rect())
            if not intersection.isEmpty():
                sub_image = self.image.copy(intersection)
                offset = QPointF(intersection.x() - sel_rect.x(), intersection.y() - sel_rect.y())
                painter = QPainter(composite)
                painter.drawImage(offset, sub_image)
                painter.end()
            for reveal in self.reveal_rectangles:
                r = reveal.mapRectToScene(reveal.rect()).toRect()
                intersection = r.intersected(sel_rect)
                if not intersection.isEmpty():
                    painter = QPainter(composite)
                    painter.fillRect(QRectF(intersection.x() - sel_rect.x(), intersection.y() - sel_rect.y(),
                                              intersection.width(), intersection.height()), Qt.black)
                    painter.end()
        else:
            for reveal in self.reveal_rectangles:
                r = reveal.mapRectToScene(reveal.rect()).toRect()
                intersection = r.intersected(sel_rect)
                if not intersection.isEmpty():
                    sub_image = self.image.copy(intersection)
                    painter = QPainter(composite)
                    offset = QPointF(intersection.x() - sel_rect.x(), intersection.y() - sel_rect.y())
                    painter.drawImage(offset, sub_image)
                    painter.end()
        
        pixmap = QPixmap.fromImage(composite)
        scaled_pixmap = pixmap.scaled(self.second_screen_geometry.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        final_pixmap = QPixmap(self.second_screen_geometry.size())
        final_pixmap.fill(Qt.black)
        painter = QPainter(final_pixmap)
        x = (final_pixmap.width() - scaled_pixmap.width()) // 2
        y = (final_pixmap.height() - scaled_pixmap.height()) // 2
        painter.drawPixmap(x, y, scaled_pixmap)
        painter.end()
        
        self.second_window.updateImage(final_pixmap)
    
    def closeEvent(self, event):
        self.second_window.close()
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    image_path = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_IMAGE_PATH
    monitor_index = int(sys.argv[2]) if len(sys.argv) > 2 else None
    window = MainWindow(image_path, monitor_index)
    sys.exit(app.exec_())
