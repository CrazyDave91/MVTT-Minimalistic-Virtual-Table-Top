"""
********************************************************************************
This code was generated by an AI language model (ChatGPT, version GPT-4) on 2025-02-28.
DISCLAIMER: This code is provided "as-is" without any warranty. It is intended for 
educational and informational purposes only. Use it at your own risk.
********************************************************************************
"""

import sys
from PyQt5.QtCore import Qt, QTimer, QRectF, QPointF
from PyQt5.QtGui import QPixmap, QPen, QColor, QPainter, QImage
from PyQt5.QtWidgets import (
    QApplication,
    QMainWindow,
    QGraphicsView,
    QGraphicsScene,
    QGraphicsPixmapItem,
    QGraphicsRectItem,
    QLabel,
    QWidget,
    QVBoxLayout,
)

# Default image path – falls kein Bild übergeben wird
DEFAULT_IMAGE_PATH = "default.jpg"

# Feste Punktgröße in Gerät-Pixeln (diese Größe bleibt konstant)
FIXED_YELLOW_DOT_SIZE = 4

# -----------------------------
# Reveal Rectangle for Cover Mode (non-interactive after creation)
# -----------------------------
class RevealRect(QGraphicsRectItem):
    def __init__(self, rect, parent=None):
        super().__init__(rect, parent)
        self.setPen(QPen(QColor(0, 255, 0), 2))
        self.setBrush(QColor(0, 255, 0, 50))
        self.setFlags(QGraphicsRectItem.GraphicsItemFlags(0))

# -----------------------------
# Selection Rectangle (always visible)
# -----------------------------
class SelectionRect(QGraphicsRectItem):
    def __init__(self, rect, main_window, parent=None):
        # Definiere das lokale Rechteck beginnend bei (0,0)
        super().__init__(QRectF(0, 0, rect.width(), rect.height()), parent)
        self.main_window = main_window
        # Das rote Rechteck soll verschiebbar sein – im Cover Mode nur, wenn Shift gedrückt ist.
        self.setFlags(QGraphicsRectItem.ItemIsSelectable | 
                      QGraphicsRectItem.ItemIsMovable | 
                      QGraphicsRectItem.ItemSendsGeometryChanges)
        self.setPen(QPen(QColor(255, 0, 0), 2))
        self.setBrush(QColor(255, 0, 0, 50))
        self.moving = False  # Flag, ob das Rechteck bewegt wird
        # Die Größe des gelben Lineal-Indikators wird nicht dynamisch skaliert, sondern ist fix in Gerät-Pixeln.
        self.yellow_size = FIXED_YELLOW_DOT_SIZE  

    def mousePressEvent(self, event):
        if self.main_window.coverModeEnabled:
            if event.button() == Qt.LeftButton and (event.modifiers() & Qt.ShiftModifier):
                self.moving = True
                super().mousePressEvent(event)
            else:
                event.ignore()
        else:
            if event.button() == Qt.LeftButton:
                self.moving = True
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self.moving:
            super().mouseMoveEvent(event)
        else:
            event.ignore()

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton and self.moving:
            self.moving = False
            super().mouseReleaseEvent(event)
        else:
            event.ignore()

    def wheelEvent(self, event):
        if event.modifiers() & Qt.ShiftModifier:
            delta = event.delta()
            # Umgekehrte Logik: Scroll up -> verkleinern, scroll down -> vergrößern.
            factor = 1.0 - (delta / 6000.0)
            rect = self.rect()  # Lokales Rechteck, beginnend bei (0,0)
            new_width = rect.width() * factor
            new_height = rect.height() * factor
            # Erhalte die aktuelle Position der oberen linken Ecke in Szenenkoordinaten
            top_left_scene = self.mapToScene(QPointF(0, 0))
            # Setze das lokale Rechteck neu (beginnt bei (0,0))
            self.setRect(0, 0, new_width, new_height)
            # Positioniere das Item so, dass die obere linke Ecke stationär bleibt.
            self.setPos(top_left_scene)
            event.accept()
        else:
            event.ignore()

    def paint(self, painter, option, widget):
        super().paint(painter, option, widget)
        # Berechne die Größe des roten Rechtecks in Szenenkoordinaten.
        sel_rect_scene = self.mapRectToScene(self.rect())
        
        # Berechne den Skalierungsfaktor, der angibt, wie das lokale Rechteck auf den zweiten Monitor projiziert wird.
        scale_factor = min(
            self.main_window.second_screen_geometry.width() / sel_rect_scene.width(),
            self.main_window.second_screen_geometry.height() / sel_rect_scene.height()
        )
        
        # Auf dem zweiten Monitor entspricht 1 Inch (Zoll) logicalDotsPerInch Pixeln.
        # Um diesen Abstand in lokalen Koordinaten zu erhalten, teilen wir den gewünschten Abstand (in Pixeln)
        # durch den Skalierungsfaktor.
        spacing = self.main_window.second_qscreen.logicalDotsPerInch() / scale_factor
        
        # Die Punktgröße bleibt fix – in Gerät-Pixeln (z. B. FIXED_YELLOW_DOT_SIZE).
        dot_diameter = FIXED_YELLOW_DOT_SIZE  
        dot_radius = dot_diameter / 2

        painter.setPen(Qt.NoPen)
        painter.setBrush(QColor(255, 255, 0, 200))  # Gelb, etwas opak

        local_rect = self.rect()  # Lokales Rechteck, beginnt bei (0,0)

        # Obere Kante:
        x = 0
        while x <= local_rect.width():
            painter.drawEllipse(QPointF(x, 0), dot_radius, dot_radius)
            x += spacing
        # Untere Kante:
        x = 0
        while x <= local_rect.width():
            painter.drawEllipse(QPointF(x, local_rect.height()), dot_radius, dot_radius)
            x += spacing
        # Linke Kante:
        y = 0
        while y <= local_rect.height():
            painter.drawEllipse(QPointF(0, y), dot_radius, dot_radius)
            y += spacing
        # Rechte Kante:
        y = 0
        while y <= local_rect.height():
            painter.drawEllipse(QPointF(local_rect.width(), y), dot_radius, dot_radius)
            y += spacing

# -----------------------------
# Main View: Displays the image and handles creation of reveal rectangles in Cover Mode
# -----------------------------
class MainView(QGraphicsView):
    def __init__(self, scene, main_window, parent=None):
        super().__init__(scene, parent)
        self.main_window = main_window
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.setMouseTracking(True)
        self.setBackgroundBrush(Qt.white)
        self._reveal_start = None
        self._temp_reveal_item = None

    def resizeEvent(self, event):
        super().resizeEvent(event)
        self.fitInView(self.sceneRect(), Qt.KeepAspectRatio)

    def mousePressEvent(self, event):
        if self.main_window.coverModeEnabled and not (event.modifiers() & Qt.ShiftModifier) and event.button() == Qt.LeftButton:
            self._reveal_start = self.mapToScene(event.pos())
            self._temp_reveal_item = QGraphicsRectItem(QRectF(self._reveal_start, self._reveal_start))
            self._temp_reveal_item.setPen(QPen(QColor(0, 255, 0), 2))
            self._temp_reveal_item.setBrush(QColor(0, 255, 0, 50))
            self._temp_reveal_item.setFlags(QGraphicsRectItem.GraphicsItemFlags(0))
            self.scene().addItem(self._temp_reveal_item)
            event.accept()
        else:
            super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self._reveal_start is not None:
            current_point = self.mapToScene(event.pos())
            rect = QRectF(self._reveal_start, current_point).normalized()
            self._temp_reveal_item.setRect(rect)
            event.accept()
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        if self._reveal_start is not None and event.button() == Qt.LeftButton:
            final_rect = self._temp_reveal_item.rect()
            if final_rect.width() > 5 and final_rect.height() > 5:
                permanent_reveal = RevealRect(final_rect)
                self.scene().addItem(permanent_reveal)
                self.main_window.reveal_rectangles.append(permanent_reveal)
            self.scene().removeItem(self._temp_reveal_item)
            self._temp_reveal_item = None
            self._reveal_start = None
            event.accept()
        else:
            super().mouseReleaseEvent(event)

# -----------------------------
# Second Window: Displays the composed image (non-interactive)
# -----------------------------
class SecondWindow(QWidget):
    def __init__(self, screen_geometry, second_qscreen, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Second Screen")
        self.setStyleSheet("background-color: black;")
        self.setGeometry(screen_geometry)
        self.second_qscreen = second_qscreen
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        self.label = QLabel()
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setStyleSheet("background-color: black;")
        self.label.setMargin(0)
        layout.addWidget(self.label)
        self.setLayout(layout)
        self.showFullScreen()
    
    def updateImage(self, pixmap: QPixmap):
        self.label.setPixmap(pixmap)

# -----------------------------
# Main Window: Manages the window and shortcuts
# -----------------------------
class MainWindow(QMainWindow):
    def __init__(self, image_path, monitor_index=None):
        super().__init__()
        self.coverModeEnabled = True  
        self.invertedCover = False  
        self.current_mode_title = "MVTT - Cover Mode"
        self.setWindowTitle(self.current_mode_title)
        
        self.image = QImage(image_path)
        if self.image.isNull():
            print("Error: Could not load image.")
            sys.exit(1)
        self.pixmap = QPixmap.fromImage(self.image)
        
        self.scene = QGraphicsScene(0, 0, self.image.width(), self.image.height())
        self.pixmap_item = QGraphicsPixmapItem(self.pixmap)
        self.scene.addItem(self.pixmap_item)
        
        screens = QApplication.screens()
        if monitor_index is None:
            if len(screens) > 1:
                second_screen = screens[1]
            else:
                second_screen = screens[0]
        else:
            if monitor_index < len(screens):
                second_screen = screens[monitor_index]
            else:
                second_screen = screens[0]
        self.second_qscreen = second_screen
        self.second_screen_geometry = second_screen.geometry()
        aspect_ratio = self.second_screen_geometry.width() / self.second_screen_geometry.height()
        
        # Erstelle das rote Auswahlrechteck als lokales Rechteck (beginnend bei 0,0) und positioniere es.
        rect_width = self.image.width() / 3
        rect_height = rect_width / aspect_ratio
        init_rect = QRectF(0, 0, rect_width, rect_height)
        self.selection_rect = SelectionRect(init_rect, main_window=self)
        pos_x = (self.image.width() - rect_width) / 2
        pos_y = (self.image.height() - rect_height) / 2
        self.selection_rect.setPos(pos_x, pos_y)
        # Das gelbe Lineal: Wir verwenden FIXED_YELLOW_DOT_SIZE als feste Punktgröße.
        self.selection_rect.yellow_size = FIXED_YELLOW_DOT_SIZE
        self.scene.addItem(self.selection_rect)
        
        self.reveal_rectangles = []
        
        self.view = MainView(self.scene, self)
        self.setCentralWidget(self.view)
        self.resize(self.image.width() // 2, self.image.height() // 2)
        self.show()
        
        self.second_window = SecondWindow(self.second_screen_geometry, self.second_qscreen)
        
        self.timer = QTimer()
        self.timer.timeout.connect(self.updateSecondWindow)
        self.timer.start(30)
    
    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Shift:
            self.setWindowTitle("MVTT - Moving Mode")
            event.accept()
            return
        elif event.key() == Qt.Key_I:
            self.invertedCover = not self.invertedCover
            mode_text = "Inverted Cover Mode" if self.invertedCover else "Cover Mode"
            self.current_mode_title = f"MVTT - {mode_text}"
            if not (event.modifiers() & Qt.ShiftModifier):
                self.setWindowTitle(self.current_mode_title)
        elif event.key() == Qt.Key_R:
            for reveal in self.reveal_rectangles:
                self.scene.removeItem(reveal)
            self.reveal_rectangles = []
        elif event.key() == Qt.Key_PageUp:
            self.resizeSelectionRect(0.98)
        elif event.key() == Qt.Key_PageDown:
            self.resizeSelectionRect(1.02)
        else:
            super().keyPressEvent(event)
    
    def keyReleaseEvent(self, event):
        if event.key() == Qt.Key_Shift:
            self.setWindowTitle(self.current_mode_title)
            event.accept()
            return
        else:
            super().keyReleaseEvent(event)
    
    def resizeSelectionRect(self, factor):
        old_rect = self.selection_rect.rect()
        new_width = old_rect.width() * factor
        new_height = old_rect.height() * factor
        # Damit die obere linke Ecke stationär bleibt, setzen wir das lokale Rechteck neu (beginnend bei (0,0))
        self.selection_rect.setRect(0, 0, new_width, new_height)
        # Die Position bleibt unverändert (die obere linke Ecke des Items entspricht der Szene-Position)
    
    def updateSecondWindow(self):
        sel_rect = self.selection_rect.mapRectToScene(self.selection_rect.rect()).toRect()
        
        # Hier wird das gelbe Lineal nicht weiter aktualisiert, da seine Größe fest ist.
        
        composite = QImage(sel_rect.size(), QImage.Format_ARGB32)
        composite.fill(Qt.black)
        
        if self.invertedCover:
            intersection = sel_rect.intersected(self.image.rect())
            if not intersection.isEmpty():
                sub_image = self.image.copy(intersection)
                offset = QPointF(intersection.x() - sel_rect.x(), intersection.y() - sel_rect.y())
                painter = QPainter(composite)
                painter.drawImage(offset, sub_image)
                painter.end()
            for reveal in self.reveal_rectangles:
                r = reveal.mapRectToScene(reveal.rect()).toRect()
                intersection = r.intersected(sel_rect)
                if not intersection.isEmpty():
                    painter = QPainter(composite)
                    painter.fillRect(QRectF(intersection.x() - sel_rect.x(), intersection.y() - sel_rect.y(),
                                              intersection.width(), intersection.height()), Qt.black)
                    painter.end()
        else:
            for reveal in self.reveal_rectangles:
                r = reveal.mapRectToScene(reveal.rect()).toRect()
                intersection = r.intersected(sel_rect)
                if not intersection.isEmpty():
                    sub_image = self.image.copy(intersection)
                    painter = QPainter(composite)
                    offset = QPointF(intersection.x() - sel_rect.x(), intersection.y() - sel_rect.y())
                    painter.drawImage(offset, sub_image)
                    painter.end()
        
        pixmap = QPixmap.fromImage(composite)
        scaled_pixmap = pixmap.scaled(self.second_screen_geometry.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        final_pixmap = QPixmap(self.second_screen_geometry.size())
        final_pixmap.fill(Qt.black)
        painter = QPainter(final_pixmap)
        x = (final_pixmap.width() - scaled_pixmap.width()) // 2
        y = (final_pixmap.height() - scaled_pixmap.height()) // 2
        painter.drawPixmap(x, y, scaled_pixmap)
        painter.end()
        
        self.second_window.updateImage(final_pixmap)
    
    def closeEvent(self, event):
        self.second_window.close()
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    image_path = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_IMAGE_PATH
    monitor_index = int(sys.argv[2]) if len(sys.argv) > 2 else None
    window = MainWindow(image_path, monitor_index)
    sys.exit(app.exec_())
