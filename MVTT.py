"""
********************************************************************************
This code was generated by an AI language model (ChatGPT, version GPT-4) on 2025-02-18.
DISCLAIMER: This code is provided "as-is" without any warranty. It is intended for 
educational and informational purposes only. Use it at your own risk.
********************************************************************************
"""

import sys
from PyQt5.QtCore import Qt, QTimer, QRectF
from PyQt5.QtGui import QPixmap, QPen, QColor, QPainter, QImage
from PyQt5.QtWidgets import (
    QApplication,
    QMainWindow,
    QGraphicsView,
    QGraphicsScene,
    QGraphicsPixmapItem,
    QGraphicsRectItem,
    QLabel,
    QWidget,
    QVBoxLayout,
)

# Standard-Pfad zum Bild – kann per Kommandozeilenparameter überschrieben werden
DEFAULT_IMAGE_PATH = "default.jpg"

# Hilfsklasse: Interaktives Auswahlrechteck (ohne Rotation)
class SelectionRect(QGraphicsRectItem):
    def __init__(self, rect, parent=None):
        super().__init__(rect, parent)
        self.setFlags(
            QGraphicsRectItem.ItemIsMovable |
            QGraphicsRectItem.ItemIsSelectable |
            QGraphicsRectItem.ItemSendsGeometryChanges
        )
        self.setPen(QPen(QColor(255, 0, 0), 2))
        self.setBrush(QColor(255, 0, 0, 50))
    
    def wheelEvent(self, event):
        # Skalierung per Mausrad (bei gedrückter Shift-Taste)
        if event.modifiers() & Qt.ShiftModifier:
            # QGraphicsSceneWheelEvent unterstützt kein angleDelta(), daher event.delta()
            delta = event.delta()
            factor = 1.0 + (delta / 2000.0)
            rect = self.rect()
            new_width = rect.width() * factor
            new_height = rect.height() * factor
            self.setRect(rect.x(), rect.y(), new_width, new_height)
        else:
            super().wheelEvent(event)

# Hauptansicht: Zeigt das Bild und das Auswahlrechteck
class MainView(QGraphicsView):
    def __init__(self, scene, parent=None):
        super().__init__(scene, parent)
        self.setRenderHint(QPainter.Antialiasing)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.setMouseTracking(True)
        self.setBackgroundBrush(Qt.white)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        # Skaliere das Bild so, dass es das Fenster ausfüllt, behalte dabei das Seitenverhältnis bei.
        self.fitInView(self.sceneRect(), Qt.KeepAspectRatio)

# Zweites Fenster: Zeigt den ausgewählten Bildausschnitt
class SecondWindow(QWidget):
    def __init__(self, screen_geometry, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Second Screen")
        # Setze das Fenster selbst schwarz
        self.setStyleSheet("background-color: black;")
        # Positioniere das Fenster auf dem gewünschten Monitor (oder dem primären, falls nur einer vorhanden ist)
        self.setGeometry(screen_geometry)
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        self.label = QLabel()
        self.label.setAlignment(Qt.AlignCenter)
        self.label.setStyleSheet("background-color: black;")
        self.label.setMargin(0)
        layout.addWidget(self.label)
        self.setLayout(layout)
        self.showFullScreen()
    
    def updateImage(self, pixmap: QPixmap):
        self.label.setPixmap(pixmap)

# Hauptfenster, das beide Fenster verwaltet
class MainWindow(QMainWindow):
    def __init__(self, image_path, monitor_index=None):
        super().__init__()
        self.setWindowTitle("Main Screen")
        # Lade das Bild als QImage (für exakte Kopien) und als QPixmap (für die Szene)
        self.image = QImage(image_path)
        if self.image.isNull():
            print("Fehler: Bild konnte nicht geladen werden.")
            sys.exit(1)
        self.pixmap = QPixmap.fromImage(self.image)
        
        # Erstelle eine Szene, deren Koordinaten dem Originalbild entsprechen
        self.scene = QGraphicsScene(0, 0, self.image.width(), self.image.height())
        self.pixmap_item = QGraphicsPixmapItem(self.pixmap)
        self.scene.addItem(self.pixmap_item)
        
        # Bestimme den Monitor für das zweite Fenster
        screens = QApplication.screens()
        if monitor_index is None:
            if len(screens) > 1:
                second_screen = screens[1]
            else:
                second_screen = screens[0]
        else:
            if monitor_index < len(screens):
                second_screen = screens[monitor_index]
            else:
                second_screen = screens[0]
        self.second_screen_geometry = second_screen.geometry()
        aspect_ratio = self.second_screen_geometry.width() / self.second_screen_geometry.height()
        
        # Starte mit einem Auswahlrechteck, das z. B. 1/3 der Bildbreite hat,
        # und dessen Höhe anhand des Monitor-Seitenverhältnisses berechnet wird.
        rect_width = self.image.width() / 3
        rect_height = rect_width / aspect_ratio
        init_rect = QRectF(
            (self.image.width() - rect_width) / 2,
            (self.image.height() - rect_height) / 2,
            rect_width,
            rect_height,
        )
        self.selection_rect = SelectionRect(init_rect)
        self.scene.addItem(self.selection_rect)
        
        # Erstelle die Hauptansicht und passe sie an
        self.view = MainView(self.scene)
        self.setCentralWidget(self.view)
        self.resize(self.image.width() // 2, self.image.height() // 2)
        self.show()
        
        # Erstelle das zweite Fenster (auf dem gewünschten Monitor)
        self.second_window = SecondWindow(self.second_screen_geometry)
        
        # Timer zum regelmäßigen Aktualisieren des zweiten Fensters
        self.timer = QTimer()
        self.timer.timeout.connect(self.updateSecondWindow)
        self.timer.start(30)  # ca. 33 FPS
        
    def updateSecondWindow(self):
        # Ermittle das Auswahlrechteck in Szene-Koordinaten
        mapped_rect = self.selection_rect.mapRectToScene(self.selection_rect.rect())
        sel_rect = mapped_rect.toRect()  # Ganzzahliger Bereich des Auswahlrechtecks
        
        # Erstelle ein neues QImage in der Größe des Auswahlrechtecks, schwarz gefüllt
        composite = QImage(sel_rect.size(), QImage.Format_ARGB32)
        composite.fill(Qt.black)
        
        # Berechne die Überschneidung des Auswahlrechtecks mit dem Originalbild
        intersection = sel_rect.intersected(self.image.rect())
        if not intersection.isEmpty():
            # Kopiere den überlappenden Teil aus dem Originalbild
            sub_image = self.image.copy(intersection)
            # Berechne den Versatz im composite, falls das Auswahlrechteck teilweise außerhalb liegt
            offset_x = intersection.x() - sel_rect.x()
            offset_y = intersection.y() - sel_rect.y()
            painter = QPainter(composite)
            painter.drawImage(offset_x, offset_y, sub_image)
            painter.end()
        
        # Konvertiere das composite Bild in ein QPixmap
        pixmap = QPixmap.fromImage(composite)
        # Skaliere das Pixmap, dabei das Seitenverhältnis beibehalten
        scaled_pixmap = pixmap.scaled(self.second_screen_geometry.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        
        # Erstelle ein finales QPixmap, das exakt die Fenstergröße hat und fülle es mit Schwarz
        final_pixmap = QPixmap(self.second_screen_geometry.size())
        final_pixmap.fill(Qt.black)
        painter = QPainter(final_pixmap)
        # Zentriere das skalierte Pixmap
        x = (final_pixmap.width() - scaled_pixmap.width()) // 2
        y = (final_pixmap.height() - scaled_pixmap.height()) // 2
        painter.drawPixmap(x, y, scaled_pixmap)
        painter.end()
        
        self.second_window.updateImage(final_pixmap)
    
    def closeEvent(self, event):
        # Schließe auch das zweite Fenster, wenn das Hauptfenster geschlossen wird.
        self.second_window.close()
        event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    # Erlaube einen Parameter beim Start: Der erste Parameter ist das Bild,
    # der zweite (optional) der Index des Monitors für das zweite Fenster.
    image_path = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_IMAGE_PATH
    monitor_index = int(sys.argv[2]) if len(sys.argv) > 2 else None
    window = MainWindow(image_path, monitor_index)
    sys.exit(app.exec_())
